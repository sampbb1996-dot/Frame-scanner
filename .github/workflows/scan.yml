#!/usr/bin/env python3
"""
Reselling Governor Bot (constraint-first, pull-based)

SOURCE (pull-based):
- Gumtree Saved Search email alerts (IMAP)

DOES:
- Parse Gumtree alert emails
- Extract per-listing URL + nearest price (local window around each URL line)
- Route each email into an isolated "search profile" (multiple saved searches)
- Apply a terminal governor per profile (binary allow/deny)
- Notify (stdout + Telegram)
- Deduplicate per (profile, url)

DOES NOT:
- Scrape websites
- Message sellers / negotiate / persuade
- Auto-buy / auto-post / auto-anything
"""

import imaplib
import email
from email.header import decode_header
import re
import sqlite3
import time
from dataclasses import dataclass
from typing import Optional, List, Tuple, Dict, Any

import requests

# =========================
# CONFIG (EDIT THESE)
# =========================

IMAP_HOST = "imap.gmail.com"
IMAP_USER = "YOUR_GMAIL_ADDRESS"
IMAP_PASS = "YOUR_GMAIL_APP_PASSWORD"   # Gmail App Password recommended
IMAP_FOLDER = "INBOX"
POLL_SECONDS = 60

# Identify Gumtree alert messages (loose, robust)
GUMTREE_FROM_HINT = "gumtree"

# Terminal constraints (defaults; profiles can override)
DEFAULT_MIN_ROI = 0.35
DEFAULT_MIN_PROFIT_AUD = 40.0

# Labor-cost survival (hard friction costs)
HOURLY_VALUE_AUD = 35.0
DEFAULT_PICKUP_MIN = 35
DEFAULT_FLIP_TIME_MIN = 15
DEFAULT_FUEL_COST_AUD = 8.0

# Telegram (notify-only)
TELEGRAM_BOT_TOKEN = "YOUR_TELEGRAM_BOT_TOKEN"
TELEGRAM_CHAT_ID = "YOUR_CHAT_ID"

# Multiple "saved searches" isolation via subject matching.
# Add/remove profiles freely; no learning/optimization happens.
SEARCH_PROFILES: Dict[str, Dict[str, Any]] = {
    "chairs": {
        "subject_hint": r"\bchair|seating|stool|desk\s*chair\b",
        "min_profit": 40.0,
        "min_roi": 0.35,
    },
    "tools": {
        "subject_hint": r"\btool|drill|saw|makita|dewalt|milwaukee\b",
        "min_profit": 50.0,
        "min_roi": 0.40,
    },
    "audio": {
        "subject_hint": r"\bspeaker|amp|audio|stereo|sony\b",
        "min_profit": 35.0,
        "min_roi": 0.30,
    },
}

# Simple resale heuristics (mechanical only)
# If no heuristic matches, listing is denied (no guessing).
HEURISTICS: List[Tuple[str, float]] = [
    (r"\bherman\s*miller\b", 2.0),
    (r"\beames\b", 2.0),
    (r"\bdyson\b", 1.7),
    (r"\bsony\b", 1.6),
    (r"\bmakita\b", 1.8),
    (r"\bdewalt\b", 1.8),
    (r"\bmilwaukee\b", 1.8),
    (r"\blego\b", 1.6),
    (r"\bguitar\b", 1.5),
]

DB_PATH = "resell_bot.sqlite3"


# =========================
# MODEL
# =========================

@dataclass(frozen=True)
class Listing:
    source: str
    msg_id: str
    profile: str
    subject: str
    url: str
    price_aud: Optional[float]


# =========================
# GOVERNOR (TERMINAL)
# =========================

class Governor:
    """
    Terminal governor:
    - No learning
    - No ranking
    - No tuning
    - Only binary gates based on explicit, posted price + mechanical resale proxy + labor-cost survival
    """
    def allow(self, listing: Listing, profile_cfg: Dict[str, Any]) -> Tuple[bool, str]:
        min_profit = float(profile_cfg.get("min_profit", DEFAULT_MIN_PROFIT_AUD))
        min_roi = float(profile_cfg.get("min_roi", DEFAULT_MIN_ROI))

        # Gate 0: must have explicit posted price
        if listing.price_aud is None or listing.price_aud <= 0:
            return False, "DENY: no explicit price"

        # Gate 1: must have a mechanical resale estimate (heuristics only)
        est_resale = estimate_resale(listing.subject, listing.price_aud)
        if est_resale is None:
            return False, "DENY: no heuristic match"

        # Gate 2: must survive real labor/friction costs
        costs = estimate_costs()
        buy_total = listing.price_aud + costs
        profit = est_resale - buy_total
        if profit < min_profit:
            return False, f"DENY: profit {profit:.0f} < {min_profit:.0f}"

        roi = profit / buy_total if buy_total > 0 else -1.0
        if roi < min_roi:
            return False, f"DENY: ROI {roi:.2f} < {min_roi:.2f}"

        return True, f"ALLOW [{listing.profile}] resale≈{est_resale:.0f} profit≈{profit:.0f} ROI≈{roi:.2f}"


def estimate_costs() -> float:
    minutes = DEFAULT_PICKUP_MIN + DEFAULT_FLIP_TIME_MIN
    labor = (minutes / 60.0) * HOURLY_VALUE_AUD
    return labor + DEFAULT_FUEL_COST_AUD


def estimate_resale(subject: str, price: float) -> Optional[float]:
    s = (subject or "").lower()
    for pattern, mult in HEURISTICS:
        if re.search(pattern, s):
            return price * float(mult)
    return None


# =========================
# EMAIL PARSING (IMPROVED)
# =========================

URL_RE = re.compile(r"https?://[^\s<>\"]+")
# Accept $123, $1,234, $123.45
PRICE_RE = re.compile(r"\$([0-9]{1,3}(?:,[0-9]{3})*|[0-9]+)(?:\.\d{2})?")

def decode_mime(s: str) -> str:
    parts = decode_header(s or "")
    out = []
    for text, enc in parts:
        if isinstance(text, bytes):
            out.append(text.decode(enc or "utf-8", errors="replace"))
        else:
            out.append(text)
    return "".join(out)

def extract_text(msg: email.message.Message) -> str:
    """
    Prefer text/plain; fallback to first part if needed.
    Keep it simple/robust.
    """
    if msg.is_multipart():
        # prefer text/plain
        for part in msg.walk():
            ctype = part.get_content_type()
            disp = str(part.get("Content-Disposition") or "")
            if "attachment" in disp.lower():
                continue
            if ctype == "text/plain":
                payload = part.get_payload(decode=True) or b""
                return payload.decode(part.get_content_charset() or "utf-8", errors="replace")
        # fallback: first non-attachment text/*
        for part in msg.walk():
            ctype = part.get_content_type()
            disp = str(part.get("Content-Disposition") or "")
            if "attachment" in disp.lower():
                continue
            if ctype.startswith("text/"):
                payload = part.get_payload(decode=True) or b""
                text = payload.decode(part.get_content_charset() or "utf-8", errors="replace")
                # ultra-light html strip if needed
                if ctype == "text/html":
                    text = re.sub(r"<[^>]+>", " ", text)
                return text
        return ""
    payload = msg.get_payload(decode=True) or b""
    return payload.decode(msg.get_content_charset() or "utf-8", errors="replace")

def match_profile(subject: str) -> Optional[str]:
    subj = (subject or "").lower()
    for name, cfg in SEARCH_PROFILES.items():
        hint = cfg.get("subject_hint")
        if hint and re.search(hint, subj, flags=re.IGNORECASE):
            return name
    return None

def parse_gumtree_alert(raw: bytes, msg_id: str) -> Tuple[str, List[Tuple[str, Optional[float]]]]:
    """
    Returns (subject, [(url, price_nearby), ...])

    Price parsing:
    - for each URL line, scan within ±3 lines for the first $price
    - strict: if none found, price=None (governor will deny)
    """
    msg = email.message_from_bytes(raw)
    subject = decode_mime(msg.get("Subject", "")).strip()
    body = extract_text(msg)

    lines = body.splitlines()
    found: List[Tuple[str, Optional[float]]] = []

    for i, line in enumerate(lines):
        m = URL_RE.search(line)
        if not m:
            continue
        url = m.group(0)

        # Gumtree listing URLs often contain /s-ad/; keep a loose filter
        if "gumtree" not in url.lower():
            continue

        # Find nearest price in local window ±3 lines
        price: Optional[float] = None
        for j in range(max(0, i - 3), min(len(lines), i + 4)):
            pm = PRICE_RE.search(lines[j])
            if pm:
                raw_num = pm.group(1).replace(",", "")
                try:
                    price = float(raw_num)
                    break
                except ValueError:
                    pass

        found.append((url, price))

    # If email includes no direct URL lines, do a fallback scan for gumtree URLs anywhere
    if not found:
        urls = URL_RE.findall(body)
        urls = [u for u in urls if "gumtree" in u.lower()]
        # no reliable way to assign per-url prices; keep None so governor denies
        for u in urls[:20]:
            found.append((u, None))

    return subject, found


# =========================
# DB (DEDUPE PER PROFILE+URL)
# =========================

def init_db() -> None:
    con = sqlite3.connect(DB_PATH)
    cur = con.cursor()
    cur.execute("""
        CREATE TABLE IF NOT EXISTS seen (
            profile TEXT NOT NULL,
            url TEXT NOT NULL,
            ts INTEGER NOT NULL,
            PRIMARY KEY(profile, url)
        )
    """)
    con.commit()
    con.close()

def is_seen(profile: str, url: str) -> bool:
    con = sqlite3.connect(DB_PATH)
    cur = con.cursor()
    cur.execute("SELECT 1 FROM seen WHERE profile=? AND url=? LIMIT 1", (profile, url))
    row = cur.fetchone()
    con.close()
    return row is not None

def mark_seen(profile: str, url: str) -> None:
    con = sqlite3.connect(DB_PATH)
    cur = con.cursor()
    cur.execute(
        "INSERT OR IGNORE INTO seen(profile, url, ts) VALUES (?,?,?)",
        (profile, url, int(time.time()))
    )
    con.commit()
    con.close()


# =========================
# TELEGRAM NOTIFY (READ-ONLY)
# =========================

def telegram_notify(text: str) -> None:
    if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
        return
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    payload = {
        "chat_id": TELEGRAM_CHAT_ID,
        "text": text,
        "disable_web_page_preview": True,
    }
    try:
        requests.post(url, json=payload, timeout=10)
    except Exception:
        # Notify is best-effort; never escalate into retries
        pass


# =========================
# IMAP LOOP
# =========================

def imap_connect() -> imaplib.IMAP4_SSL:
    M = imaplib.IMAP4_SSL(IMAP_HOST)
    M.login(IMAP_USER, IMAP_PASS)
    M.select(IMAP_FOLDER)
    return M

def looks_like_gumtree(raw: bytes) -> bool:
    low = raw.lower()
    return (GUMTREE_FROM_HINT.encode() in low) and (b"gumtree" in low)

def read_unseen_ids(M: imaplib.IMAP4_SSL) -> List[str]:
    status, data = M.search(None, "(UNSEEN)")
    if status != "OK" or not data or not data[0]:
        return []
    return [x.decode("utf-8") for x in data[0].split()]

def fetch_rfc822(M: imaplib.IMAP4_SSL, imap_id: str) -> Optional[bytes]:
    status, data = M.fetch(imap_id, "(RFC822)")
    if status != "OK" or not data or not data[0]:
        return None
    return data[0][1]

def format_message(listing: Listing, decision: str) -> str:
    price = f"${listing.price_aud:.0f}" if listing.price_aud is not None else "N/A"
    return (
        "RESALE CANDIDATE\n"
        f"Profile: {listing.profile}\n"
        f"Price:   {price}\n"
        f"URL:     {listing.url}\n"
        f"{decision}"
    )

def main() -> None:
    init_db()
    gov = Governor()

    while True:
        try:
            M = imap_connect()
            unseen = read_unseen_ids(M)

            for imap_id in unseen:
                raw = fetch_rfc822(M, imap_id)
                if not raw:
                    continue
                if not looks_like_gumtree(raw):
                    continue

                subject, url_prices = parse_gumtree_alert(raw, imap_id)

                profile_name = match_profile(subject)
                if not profile_name:
                    # If it doesn't match a configured profile, ignore (no action).
                    continue

                profile_cfg = SEARCH_PROFILES[profile_name]

                for url, price in url_prices[:25]:
                    if is_seen(profile_name, url):
                        continue

                    listing = Listing(
                        source="gumtree_email",
                        msg_id=imap_id,
                        profile=profile_name,
                        subject=subject,
                        url=url,
                        price_aud=price,
                    )

                    allow, reason = gov.allow(listing, profile_cfg)
                    if allow:
                        msg = format_message(listing, reason)
                        print("\n" + msg + "\n")
                        telegram_notify(msg)

                    # Mark seen regardless (prevents spam loops)
                    mark_seen(profile_name, url)

            try:
                M.logout()
            except Exception:
                pass

        except Exception as e:
            print(f"[error] {type(e).__name__}: {e}")

        time.sleep(POLL_SECONDS)


if __name__ == "__main__":
    main()
